<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover"/>
    <title>Karma | Capture and Upload</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">

</head>
<body>
    <h1 class="header-title">Complete Quest</h1>
    <div class="camera-container">
        <p style="color: #555;">Quest ID: {{ quest_id_str }}</p>
        <div class="camera-feed">
            <video id="video" width="320" height="240" autoplay playsinline></video> {# Added playsinline for iOS #}
            <button id="take-photo">Take Photo</button>
            <canvas id="canvas" style="display: none;"></canvas> {# Keep canvas for drawing frame #}
        </div>
        <div class="upload-container">
            <p>Or, if you already have an image:</p>
            <form id="uploadFormFallback" method="post" enctype="multipart/form-data" action="{{ url_for('upload_endpoint') }}">
                <input type="hidden" name="quest_id_str" value="{{ quest_id_str }}">
                <label for="image-upload-fallback" class="upload-button">
                    Upload Existing Image
                </label>
                <input type="file" id="image-upload-fallback" name="image_file" accept="image/*" style="display: none;">
                {# This form will submit traditionally or can be enhanced with JS #}
            </form>
        </div>
        <div id="responseMessage"></div>
    </div>


    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const takePhotoButton = document.getElementById('take-photo');
        const responseMessageDiv = document.getElementById('responseMessage');
        const questId = "{{ quest_id_str }}"; // Get quest_id from Flask template
        const uploadEndpoint = "{{ url_for('upload_endpoint') }}"; // Get endpoint URL from Flask

        // Access the camera
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } }) // Prefer back camera
                .then(function(stream) {
                    video.srcObject = stream;
                    video.play();
                })
                .catch(function(err) {
                    console.error("Error accessing the camera: ", err);
                    responseMessageDiv.style.display = 'block';
                    responseMessageDiv.className = 'error';
                    responseMessageDiv.textContent = 'Could not access camera: ' + err.message;
                });
        } else {
            console.error("getUserMedia not supported on your browser!");
            responseMessageDiv.style.display = 'block';
            responseMessageDiv.className = 'error';
            responseMessageDiv.textContent = 'Camera access is not supported by your browser.';
        }

        // Take photo and upload
        takePhotoButton.addEventListener('click', function() {
            // Set canvas dimensions to video dimensions
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            context.drawImage(video, 0, 0, canvas.width, canvas.height);

            responseMessageDiv.style.display = 'block';
            responseMessageDiv.className = 'info';
            responseMessageDiv.textContent = 'Processing and uploading photo...';

            canvas.toBlob(function(blob) {
                const formData = new FormData();
                // Create a filename for the blob, e.g., "capture.png"
                // The server-side (gcs_uploader) will generate a more unique name for GCS.
                const fileName = `capture_${new Date().toISOString().replace(/[:.]/g, '-')}.png`;
                formData.append('image_file', blob, fileName);
                formData.append('quest_id_str', questId);
                // user_id is handled by session on the server in your /upload_endpoint

                fetch(uploadEndpoint, {
                    method: 'POST',
                    body: formData,
                })
                .then(response => response.json())
                .then(result => {
                    if (result.gcs_uri) { // Check for gcs_uri as success indicator
                        responseMessageDiv.className = 'success';
                        responseMessageDiv.textContent = result.message || 'Upload successful!';
                        if (result.gcs_uri) {
                            responseMessageDiv.textContent += ` Image URI: ${result.gcs_uri}.`;
                        }
                        if (result.karma_points_awarded !== undefined) {
                             responseMessageDiv.textContent += ` Points Awarded: ${result.karma_points_awarded}.`;
                        }
                        // Redirect to quests page after a delay
                        setTimeout(() => {
                            window.location.href = "{{ url_for('quests') }}";
                        }, 3000);
                    } else {
                        responseMessageDiv.className = 'error';
                        responseMessageDiv.textContent = `Error: ${result.error || 'Upload failed. Check server logs.'}`;
                    }
                })
                .catch(error => {
                    console.error('Error uploading image:', error);
                    responseMessageDiv.className = 'error';
                    responseMessageDiv.textContent = 'Error uploading image. Check console.';
                });
            }, 'image/png'); // Specify image format for the blob
        });

        // Handle fallback file input change for traditional form submission
        const fallbackInput = document.getElementById('image-upload-fallback');
        const fallbackForm = document.getElementById('uploadFormFallback');
        if (fallbackInput && fallbackForm) {
            fallbackInput.addEventListener('change', function() {
                if (this.files && this.files[0]) {
                    // Optionally, you could use the same fetch logic here for consistency,
                    // or let the form submit traditionally. For now, it's a traditional submit.
                    // To use fetch, you'd preventDefault and then construct FormData like above.
                    console.log("File selected via fallback, submitting form traditionally.");
                    // To make this also use fetch and show messages:
                    // fallbackForm.dispatchEvent(new Event('submit', { cancelable: true })); // if you add a submit listener to fallbackForm
                    // For simplicity, this example will let it submit traditionally if JS is not enhanced for it.
                    // If you want the same JS handling for this input, you'd need to add that logic.
                }
            });
        }

    </script>
</body>
</html>
